import { OrmaError } from '../../../helpers/error_handling'
import { escape_column } from '../../../helpers/escape'
import {
    validate_boolean,
    validate_not_empty,
    validate_string
} from '../../common/compiler_helpers'
import { validate } from '../../common/validator'
import { CompilerArgs } from '../../compiler'
import { sql_to_typescript_types } from '../sql_data_types'
import { compile_data_type } from './compile_data_type'

export const compile_column_definition = ({
    statement,
    path,
    database_type
}: CompilerArgs<ColumnDefinition>) => {
    const data_type_string = compile_data_type({
        statement,
        database_type,
        path
    })
    const not_null_string = statement.not_null ? ` NOT NULL` : ''
    const escaped_column_name = escape_column(statement.name, database_type)

    // check constraints to polyfill unsupported features in some dbs
    let check_constraints: string[] = []
    if (statement.unsigned && database_type === 'postgres') {
        check_constraints.push(`${escaped_column_name} > 0`)
    }
    if (
        statement.data_type === 'enum' &&
        statement.enum_values &&
        database_type !== 'mysql'
    ) {
        const enum_values_string = statement.enum_values
            .map(el => (database_type === 'postgres' ? `'${el}'` : `"${el}"`))
            .join(', ')
        check_constraints.push(
            `${escaped_column_name}) IN (${enum_values_string}`
        )
    }
    const check_constraint_string = check_constraints.length
        ? ` CHECK(${check_constraints.join(' AND ')})`
        : ''

    const postgres_auto_increment_string =
        statement.auto_increment && database_type === 'postgres'
            ? ' GENERATED BY DEFAULT AS IDENTITY'
            : ''

    // Sqlite needs the magic INTEGER PRIMARY KEY type to do auto incrementing,
    // so we parse $auto_incrementing as an inline PRIMARY KEY constraint
    const auto_increment_string =
        database_type === 'sqlite'
            ? 'PRIMARY KEY'
            : database_type === 'mysql'
            ? 'AUTO_INCREMENT'
            : ''

    const comment_string =
        statement.comment && database_type !== 'sqlite'
            ? ` COMMENT "${statement.comment}"`
            : ''

    const default_string = statement.default
        ? ` DEFAULT ${statement.default}`
        : ''

    return `${statement.name} ${data_type_string}${not_null_string}${default_string}${postgres_auto_increment_string}${auto_increment_string}${comment_string}${check_constraint_string}`
}

export const validate_column_definition = ({
    statement,
    path,
    database_type
}: CompilerArgs<ColumnDefinition>) => {
    const errors = validate(
        {
            type: 'object',
            properties: {
                name: { type: 'string', minLength: 1 },
                first: { type: 'boolean' },
                after: { type: 'string', minLength: 1 },
                not_null: { type: 'boolean' },
                auto_increment: { type: 'boolean' },
                default: {},
                on_update: {},
                comment: { type: 'string' }
            },
            required: ['data_type']
        },
        path,
        statement
    )

    const first_after_xor_errors: OrmaError[] =
        statement.first && statement.after
            ? [
                  {
                      error_code: 'validation_error',
                      message: `"first" and "after" cannot be used together.`
                  }
              ]
            : []

    return [...errors, ...first_after_xor_errors]
}

export type ColumnDefinition = {
    readonly name: string
    readonly data_type: keyof typeof sql_to_typescript_types
    readonly first?: boolean
    readonly after?: string
    readonly enum_values?: readonly string[]
    readonly precision?: number
    readonly scale?: number
    readonly unsigned?: boolean
    readonly not_null?: boolean
    readonly auto_increment?: boolean
    readonly default?: string | number | Record<string, any> // TODO: make this use an Expression type
    readonly on_update?: string | number | Record<string, any> // TODO: make this use an Expression type
    readonly comment?: string
}
