import { mutation_path_to_entity } from '../..'
import { OrmaError } from '../../helpers/error_handling'
import { group_by, map_object } from '../../helpers/helpers'
import {
    get_child_edges,
    get_primary_keys,
    reverse_edge,
} from '../../helpers/schema_helpers'
import { OrmaSchema } from '../../types/schema/schema_types'
import { orma_query } from '../../query/query'
import { combine_wheres } from '../../query/query_helpers'
import { PathedRecord } from '../../types'
import { sort_database_rows } from '../database_results/sort_database_rows'
import { path_to_entity } from '../helpers/mutate_helpers'
import { MysqlFunction } from '../mutate'
import { MutationPiece, MutationPlan } from '../plan/mutation_batches'
import { generate_identifying_where } from '../helpers/record_searching'
import { GuidMap } from '../macros/guid_plan_macro'

/* 
Description:
Create errors for any records connected to a delete in the mutation, where that record is not also being deleted. This
avoids getting mysql errors, or leaking ids that are not accessible.

ALgorithm:
- For each entity, remember all relevant identifying keys, that is all identifying fields that appear on at least
    one delete for that entity
- Fetch all records that have at least one parent in the mutation as a delete. Select all relevant
    identifying keys (e.g. if the child is 'users', select all identifying keys for 'users', that is all identifying keys
    that is on a user in the mutation)
- Match child records with records in the mutation
- Generate errors. Any child that is unmatched will block the delete. Matched children can be ignored

Notes:
- Can allow users to know that an id exists, even if that ID is not viewable due to connected records (multitenancy). 
    For example, if a post_group is owned by all the posts that reference it, then deleting the post_group will generate 
    an error message with all the posts inside it, even if some of those posts should be hidden.
- Doesn't handle creates and deletes interacting (e.g. create a post and delete that post's user in the same mutation).
    This case will result in an SQL error if the create is run first
- Doesn't handle udpates and deletes interacting (not sure if this can even happen, but its not supported)

*/

export const get_delete_verification_errors = async (
    orma_schema: OrmaSchema,
    mysql_function: MysqlFunction,
    mutation_plan: Pick<MutationPlan, 'mutation_pieces' | 'guid_map'>
) => {
    const query = get_delete_verification_query(
        orma_schema,
        mutation_plan.guid_map,
        mutation_plan.mutation_pieces
    )
    const results = await orma_query(query, orma_schema, mysql_function)
    const blocking_pieces = get_mutation_pieces_blocing_delete(
        orma_schema,
        mutation_plan.mutation_pieces,
        mutation_plan.guid_map,
        results
    )
    const errors = get_delete_errors_from_blocking_rows(
        orma_schema,
        blocking_pieces
    )
    return errors
}

export const get_delete_mutation_pieces_by_entity = (
    mutation_plan: Pick<MutationPlan, 'mutation_pieces'>
) => {
    const delete_pieces = mutation_plan.mutation_pieces.filter(
        el => el.record.$operation === 'delete'
    )

    const delete_pieces_by_entity = group_by(delete_pieces, el =>
        mutation_path_to_entity(el.path)
    )

    return delete_pieces_by_entity
}

export const get_delete_verification_query = (
    orma_schema: OrmaSchema,
    guid_map: GuidMap,
    mutation_pieces: MutationPiece[]
) => {
    const delete_indices_by_entity = mutation_pieces.reduce(
        (acc, mutation_piece, i) => {
            if (mutation_piece.record.$operation === 'delete') {
                const entity = mutation_path_to_entity(mutation_piece.path)
                acc[entity] = acc[entity] || []
                acc[entity].push(i)
            }
            return acc
        },
        {} as Record<string, number[]>
    )

    const identifying_fields_by_entity = map_object(
        delete_indices_by_entity,
        (entity, piece_indices) => {
            const identifying_keys = piece_indices.flatMap(
                piece_index =>
                    mutation_pieces[piece_index].record.$identifying_fields
            ) as string[]
            return [entity, new Set(identifying_keys)]
        }
    )

    const parent_entities = Object.keys(identifying_fields_by_entity)
    // - generate an object with keys that are child entities, and value that is an array of edges to parents in mutation
    // - map that object to keys being child entities and values the where clauses generated by those edges
    //     - each edge turns into an $in $where, so children are returned that are connected to a parent in the mutation

    const edges_to_parents = parent_entities.flatMap(parent_entity => {
        const child_edges = get_child_edges(parent_entity, orma_schema)
        const edges_to_parent = child_edges.map(reverse_edge)
        return edges_to_parent
    })

    const edges_to_parent_by_child_entity = group_by(
        edges_to_parents,
        edge => edge.from_entity
    )

    const query: any = map_object(
        edges_to_parent_by_child_entity,
        (child_entity, edges_to_parent, i) => {
            const child_wheres = edges_to_parent.map(edge_to_parent => {
                const parent_entity = edge_to_parent.to_entity

                const parent_wheres = delete_indices_by_entity[
                    parent_entity
                ].map(piece_index => {
                    const where = generate_identifying_where(
                        orma_schema,
                        guid_map,
                        mutation_pieces,
                        mutation_pieces[piece_index].record.$identifying_fields,
                        piece_index
                    )

                    return where
                })

                const child_where = {
                    $in: [
                        edge_to_parent.from_field,
                        {
                            $select: [edge_to_parent.to_field],
                            $from: parent_entity,
                            $where: combine_wheres(parent_wheres, '$or'),
                        },
                    ],
                }

                return child_where
            })

            const relevant_child_fields = [
                ...new Set([
                    ...get_primary_keys(child_entity, orma_schema),
                    ...(identifying_fields_by_entity?.[child_entity] ?? []),
                ]),
            ]

            return [
                child_entity,
                {
                    $select: relevant_child_fields,
                    $from: child_entity,
                    $where: combine_wheres(child_wheres, '$or'),
                },
            ]
        }
    )

    return query
}

const get_result_id_string = (
    orma_schema: OrmaSchema,
    entity: string,
    record: Record<string, any>
) => {
    const primary_keys = get_primary_keys(entity, orma_schema)
    const values = primary_keys.map(key => record[key])
    const id_string = JSON.stringify([entity, values])
    return id_string
}

export const get_mutation_pieces_blocing_delete = (
    orma_schema: OrmaSchema,
    mutation_pieces: MutationPiece[],
    guid_map: GuidMap,
    results: Record<string, Record<string, any>[] | undefined>
) => {
    const delete_indices = mutation_pieces.flatMap((mutation_piece, i) =>
        mutation_piece.record.$operation === 'delete' ? [i] : []
    )

    const result_entities = Object.keys(results)
    const result_record_groups = result_entities
        .map(entity => results[entity])
        .filter((el): el is Record<string, any>[] => el !== undefined)

    const matched_results = sort_database_rows(
        mutation_pieces,
        guid_map,
        delete_indices,
        result_entities,
        result_record_groups,
        orma_schema
    )

    const matched_primary_key_values = matched_results.reduce<Set<string>>(
        (acc, matched_result, i) => {
            if (!matched_result) {
                return acc
            }

            const id_string = get_result_id_string(
                orma_schema,
                path_to_entity(mutation_pieces[delete_indices[i]].path),
                matched_result
            )
            acc.add(id_string)

            return acc
        },
        new Set()
    )

    const blocking_pathed_records = result_record_groups.flatMap(
        (result_records, i) => {
            const entity = result_entities[i]

            const blocked_records = result_records.flatMap(result_record => {
                const id_string = get_result_id_string(
                    orma_schema,
                    entity,
                    result_record
                )

                if (matched_primary_key_values.has(id_string)) {
                    return []
                } else {
                    return [result_record]
                }
            })

            const pathed_records: PathedRecord[] = blocked_records.map(
                (record, i) => ({
                    record,
                    path: [entity, i],
                })
            )

            return pathed_records
        }
    )

    return blocking_pathed_records
}

export const get_delete_errors_from_blocking_rows = (
    orma_schema: OrmaSchema,
    blocking_pathed_records: PathedRecord[]
): OrmaError[] => {
    const errors = blocking_pathed_records.map(({ record, path }) => {
        const entity = path_to_entity(path ?? [])
        const primary_keys = get_primary_keys(entity, orma_schema)
        const primary_key_values = primary_keys.map(key => record[key])

        const errors: OrmaError = {
            message: `Cannot delete record because ${entity} ${primary_key_values.join(
                ', '
            )} is undeleted.`,
            path: [],
            additional_info: {
                record,
                entity,
            },
        }

        return errors
    })

    return errors
}
