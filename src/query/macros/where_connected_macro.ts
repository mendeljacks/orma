import { deep_for_each, deep_set, last } from '../../helpers/helpers'
import { push_path } from '../../helpers/push_path'
import {
    Edge,
    get_entity_names,
    get_parent_edges,
} from '../../helpers/schema_helpers'
import { orma_schema } from '../../introspector/introspector'
import { WhereConnected } from '../../types/query/query_types'
import { GetAllEntities, OrmaSchema } from '../../types/schema_types'
import { get_real_entity_name, get_real_higher_entity_name } from '../query'
import { combine_wheres, query_for_each } from '../query_helpers'
import { edge_path_to_where_ins, process_any_clause } from './any_path_macro'

/*
This defines the concept of 'connected' for this macro. Each entity gets a list of edges that are considered connected.
Connected paths are generated by traversing all possible paths in these edges. Each connected path then generates a where
clause that filters results to be connected via these connected paths.
 */
export type ConnectionEdges = {
    [source_entity: string]: {
        from_field: string
        to_entity: string
        to_field: string
    }[]
}

export const get_upwards_connection_edges = (orma_schema: orma_schema) => {
    const connection_edges = get_entity_names(orma_schema).reduce(
        (acc, entity_name) => {
            // dont make edges from an entity to itself. This prevents infinite loops
            const upwards_edges = get_parent_edges(
                entity_name,
                orma_schema
            ).filter(el => el.from_entity !== el.to_entity) 

            if (upwards_edges.length > 0) {
                acc[entity_name] = upwards_edges
            } 

            return acc
        },
        {} as ConnectionEdges
    )

    return connection_edges
}

const get_edge_paths_by_destination = (
    connection_edges: ConnectionEdges,
    source_entity: string
) => {
    // start off with a path to every connected edge
    const edge_paths =
        connection_edges?.[source_entity]?.map(edge => [
            { ...edge, from_entity: source_entity },
        ]) ?? []

    // every path before this index is done, in other words there are no more paths that we can get
    // by appending some connected edge onto that path
    let next_index = 0

    // keep looping while there are still paths to process
    while (next_index < edge_paths.length) {
        const current_index = next_index
        next_index = edge_paths.length
        for (let i = current_index; i < edge_paths.length; i++) {
            // for each unprocessed path, generate new paths by appending all possible
            // connected edges onto its end
            const edge_path = edge_paths[i]
            const parent_entity = last(edge_path).to_entity
            const new_paths =
                connection_edges?.[parent_entity]?.map(connection_edge => {
                    const new_edge = {
                        ...connection_edge,
                        from_entity: parent_entity,
                    }
                    return [...edge_path, new_edge]
                }) ?? []

            edge_paths.push(...new_paths)
        }
    }

    // split edge paths by entity since we only want paths to entities that are in the $where_connected clause
    const connection_paths = edge_paths.reduce(
        (acc, edge_path) => {
            const target_entity = last(edge_path).to_entity
            if (!acc[target_entity]) {
                acc[target_entity] = []
            }
            acc[target_entity].push(edge_path)
            return acc
        },
        {} as {
            [target_entity: string]: Edge[][]
        }
    )

    return connection_paths
}

export const apply_where_connected_macro = (
    query: Record<string, any>,
    connection_edges: ConnectionEdges
) => {
    if (!query.$where_connected) {
        return
    }

    query_for_each(query, (subquery, path) => {
        if (subquery.$where) {
            deep_for_each(subquery.$where, (value, path) => {
                if (value?.$from) {
                    const entity_name = value.$from
                    apply_where_connected_to_subquery(
                        connection_edges,
                        query.$where_connected,
                        value,
                        entity_name,
                        undefined
                    )
                }
            })
        }

        const entity_name = get_real_entity_name(path, subquery)
        const higher_entity = get_real_higher_entity_name(path, subquery)
        apply_where_connected_to_subquery(
            connection_edges,
            query.$where_connected,
            subquery,
            entity_name,
            higher_entity
        )
    })

    return query
}

const apply_where_connected_to_subquery = (
    connection_edges: ConnectionEdges,
    $where_connected: WhereConnected<OrmaSchema>,
    subquery: any,
    entity_name: string,
    higher_entity: string = undefined
) => {
    const existing_wheres = [subquery.$where] ?? []
    const connected_where = get_connected_where_clause(
        connection_edges,
        $where_connected,
        entity_name,
        higher_entity
    )
    const new_where = combine_wheres(
        [...existing_wheres, connected_where],
        '$and'
    )

    subquery.$where = new_where
}

const get_connected_where_clause = (
    connection_edges: ConnectionEdges,
    $where_connected: WhereConnected<OrmaSchema>,
    entity_name: string,
    higher_entity: string = undefined
) => {
    const edge_paths_by_destination = get_edge_paths_by_destination(
        connection_edges,
        entity_name
    )

    const connection_clauses = $where_connected.flatMap(
        ({ $entity, $field, $values }) => {
            // the as typeof... on this line is completely unnecessary and is here because typescript is buggy
            const all_edge_paths = (edge_paths_by_destination[$entity] ??
                []) as typeof edge_paths_by_destination[string]

            // (optimization) if the higher table is the parent table, we dont need to do extra filtering.
            // This is because orma will already filter this to be a child of the higher table,
            // so we only need to put the extra where clause on the higher table.
            // We only check the entity since the column of the foreign key is inferred by orma (there must be only one)
            const edge_paths = all_edge_paths.filter(
                edge_path =>
                    higher_entity === undefined || // if no higher entity is provided, then skip the optimization
                    edge_path[0].to_entity !== higher_entity
            )

            if (edge_paths.length === 0) {
                return []
            }

            const clauses = edge_paths.map(edge_path => {
                const clause = edge_path_to_where_ins(edge_path, '$where', {
                    $in: [$field, $values],
                })

                return clause
            })

            return clauses
        }
    )

    return combine_wheres(connection_clauses, '$and')
}

// TODO: make validation that ensures an entity / field combination cannot appear more than once in a $where_connected